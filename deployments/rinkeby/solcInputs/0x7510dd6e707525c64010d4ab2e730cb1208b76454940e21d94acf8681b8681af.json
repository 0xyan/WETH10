{
  "language": "Solidity",
  "sources": {
    "contracts/fuzzing/WETH10Fuzzing.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.0;\nimport \"../WETH10.sol\";\n\n\n/// @dev A contract that will receive weth, and allows for it to be retrieved.\ncontract MockHolder {\n    constructor (address payable weth, address retriever) {\n        WETH10(weth).approve(retriever, type(uint).max);\n    }\n}\n\n/// @dev Invariant testing\ncontract WETH10Fuzzing {\n\n    WETH10 internal weth;\n    address internal holder;\n\n    /// @dev Instantiate the WETH10 contract, and a holder address that will return weth when asked to.\n    constructor () {\n        weth = new WETH10(address(0));\n        holder = address(new MockHolder(address(weth), address(this)));\n    }\n\n    /// @dev Receive ETH when withdrawing.\n    receive () external payable { }\n\n    /// @dev Add two numbers, but return 0 on overflow\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        assert(c >= a); // Normally it would be a `require`, but we want the test to fail if there is an overflow, not to be ignored.\n    }\n\n    /// @dev Subtract two numbers, but return 0 on overflow\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        c = a - b;\n        assert(c <= a); // Normally it would be a `require`, but we want the test to fail if there is an overflow, not to be ignored.\n    }\n\n    /// @dev Test that supply and balance hold on deposit.\n    function deposit(uint ethAmount) public {\n        uint supply = address(weth).balance;\n        uint balance = weth.balanceOf(address(this));\n        weth.deposit{value: ethAmount}(); // It seems that echidna won't let the total value sent go over type(uint256).max\n        assert(address(weth).balance == add(supply, ethAmount));\n        assert(weth.balanceOf(address(this)) == add(balance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on withdraw.\n    function withdraw(uint ethAmount) public {\n        uint supply = address(weth).balance;\n        uint balance = weth.balanceOf(address(this));\n        weth.withdraw(ethAmount);\n        assert(address(weth).balance == sub(supply, ethAmount));\n        assert(weth.balanceOf(address(this)) == sub(balance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on transfer.\n    function transfer(uint ethAmount) public {\n        uint thisBalance = weth.balanceOf(address(this));\n        uint holderBalance = weth.balanceOf(holder);\n        weth.transfer(holder, ethAmount);\n        assert(weth.balanceOf(address(this)) == sub(thisBalance, ethAmount));\n        assert(weth.balanceOf(holder) == add(holderBalance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on transferFrom.\n    function transferFrom(uint ethAmount) public {\n        uint thisBalance = weth.balanceOf(address(this));\n        uint holderBalance = weth.balanceOf(holder);\n        weth.transferFrom(holder, address(this), ethAmount);\n        assert(weth.balanceOf(address(this)) == add(thisBalance, ethAmount));\n        assert(weth.balanceOf(holder) == sub(holderBalance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n}"
    },
    "contracts/WETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2020\npragma solidity 0.7.0;\n\nimport \"./IWETH10.sol\";\n\n\ninterface ERC677Receiver {\n    function onTokenTransfer(address, uint, bytes calldata) external;\n}\n\ninterface FlashMinterLike {\n    function executeOnFlashMint(bytes calldata) external;\n}\n\ninterface WETH9Like {\n    function deposit() external payable;\n    function transfer(address, uint) external returns (bool);\n}\n\n/// @dev WETH10 is an Ether ERC20 wrapper. You can `deposit` Ether and obtain Wrapped Ether which can then be operated as an ERC20 token. You can\n/// `withdraw` Ether from WETH10, which will burn Wrapped Ether in your wallet. The amount of Wrapped Ether in any wallet is always identical to the\n/// balance of Ether deposited minus the Ether withdrawn with that specific wallet.\ncontract WETH10 is IWETH10 {\n\n    string public constant name = \"Wrapped Ether v10\";\n    string public constant symbol = \"WETH10\";\n    uint8  public constant decimals = 18;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /// @dev WETH9 contract\n    WETH9Like public immutable weth9;\n\n    /// @dev Records amount of WETH10 token owned by account.\n    mapping (address => uint256) public override balanceOf;\n\n    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\n    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\n    mapping (address => uint256) public override nonces;\n\n    /// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\n    mapping (address => mapping (address => uint256)) public override allowance;\n\n    /// @dev Current amount of flash minted WETH.\n    uint256 public override flashSupply;\n\n    /// @dev The constructor takes the address of the WETH9 contract to allow conversions\n    constructor (address weth9_) {\n        weth9 = WETH9Like(weth9_);\n    }\n\n    /// @dev Fallback, `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    receive() external payable {\n        require(address(this).balance + flashSupply <= type(uint112).max, \"WETH::receive: supply limit exceeded\");\n        balanceOf[msg.sender] += msg.value;\n        emit Transfer(address(0), msg.sender, msg.value);\n    }\n\n    /// @dev Returns the total supply of WETH10 as the Ether held in this contract.\n    function totalSupply() external view override returns(uint256) {\n        return address(this).balance;\n    }\n\n    /// @dev `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    function deposit() external override payable {\n        require(address(this).balance + flashSupply <= type(uint112).max, \"WETH::deposit: supply limit exceeded\");\n        balanceOf[msg.sender] += msg.value;\n        emit Transfer(address(0), msg.sender, msg.value);\n    }\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to `to` account.\n    function depositTo(address to) external override payable {\n        require(address(this).balance + flashSupply <= type(uint112).max, \"WETH::depositTo: supply limit exceeded\");\n        require(to != address(this), \"WETH::depositTo: invalid recipient\");\n        balanceOf[to] += msg.value;\n        emit Transfer(address(0), to, msg.value);\n    }\n\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance,\n    /// after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token and transfer to account (`to`) cannot cause overflow.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function depositToAndCall(address to, bytes calldata data) external override payable returns (bool success) {\n        require(address(this).balance + flashSupply <= type(uint112).max, \"WETH::depositToAndCall: supply limit exceeded\");\n        require(to != address(this), \"WETH::depositToAndCall: invalid recipient\");\n        balanceOf[to] += msg.value;\n        emit Transfer(address(0), to, msg.value);\n\n        ERC677Receiver(to).onTokenTransfer(msg.sender, msg.value, data);\n        return true;\n    }\n\n    /// @dev Flash mints WETH10 token and burns from caller account.\n    /// The flash minted WETH10 is not backed by real Ether, but can be withdrawn as such up to the Ether balance of this contract.\n    /// Arbitrary data can be passed as a bytes calldata parameter.\n    /// Emits two {Transfer} events for minting and burning of the flash minted amount.\n    function flashMint(uint256 value, bytes calldata data) external override {\n        flashSupply += value;\n        require(address(this).balance + flashSupply <= type(uint112).max, \"WETH::flashMint: supply limit exceeded\");\n        balanceOf[msg.sender] += value;\n        emit Transfer(address(0), msg.sender, value);\n\n        FlashMinterLike(msg.sender).executeOnFlashMint(data);\n\n        require(balanceOf[msg.sender] >= value, \"WETH::flashMint: transfer amount exceeds balance\");\n        balanceOf[msg.sender] -= value;\n        flashSupply -= value;\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to the same.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdraw(uint256 value) external override {\n        require(balanceOf[msg.sender] >= value, \"WETH::withdraw: withdraw amount exceeds balance\");\n        balanceOf[msg.sender] -= value;\n\n        (bool success, ) = msg.sender.call{value: value}(\"\");\n        require(success, \"WETH::withdraw: Ether transfer failed\");\n\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdrawTo(address to, uint256 value) external override {\n        require(balanceOf[msg.sender] >= value, \"WETH::withdrawTo: withdraw amount exceeds balance\");\n        require(to != address(this), \"WETH::withdrawTo: invalid recipient\");\n        balanceOf[msg.sender] -= value;\n\n        (bool success, ) = to.call{value: value}(\"\");\n        require(success, \"WETH::withdrawTo: Ether transfer failed\");\n\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ether to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function withdrawFrom(address from, address to, uint256 value) external override {\n        require(balanceOf[from] >= value, \"WETH::withdrawFrom: withdraw amount exceeds balance\");\n        require(to != address(this), \"WETH::withdrawFrom: invalid recipient\");\n        \n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"WETH::withdrawFrom: withdraw amount exceeds allowance\");\n                allowance[from][msg.sender] = allowed - value;\n                emit Approval(from, msg.sender, allowed - value);\n            }\n        }\n        balanceOf[from] -= value;\n\n        (bool success, ) = to.call{value: value}(\"\");\n        require(success, \"WETH::withdrawFrom: Ether transfer failed\");\n\n        emit Transfer(from, address(0), value);\n    }\n\n    /// @dev Exchange `value` WETH10 token from caller account for WETH9 token.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function convert(uint256 value) external override {\n        require(balanceOf[msg.sender] >= value, \"WETH::convert: convert amount exceeds balance\");\n        balanceOf[msg.sender] -= value;\n\n        emit Transfer(msg.sender, address(0), value);\n\n        weth9.deposit{value: value}();\n        require(weth9.transfer(msg.sender, value), \"WETH::convert: WETH transfer failed\");\n    }\n\n    /// @dev Exchange `value` WETH10 token from caller account for WETH9 token credited to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function convertTo(address to, uint256 value) external override {\n        require(balanceOf[msg.sender] >= value, \"WETH::convertTo: convert amount exceeds balance\");\n        require(to != address(this), \"WETH::convertTo: invalid recipient\");\n        balanceOf[msg.sender] -= value;\n\n        emit Transfer(msg.sender, address(0), value);\n    \n        weth9.deposit{value: value}();\n        require(weth9.transfer(to, value), \"WETH::convert: WETH transfer failed\");\n    }\n\n    /// @dev Exchange `value` WETH10 token from account (`from`) for WETH9 token credited to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function convertFrom(address from, address to, uint256 value) external override {\n        require(balanceOf[from] >= value, \"WETH::convertFrom: convert amount exceeds balance\");\n        require(to != address(this), \"WETH::convertFrom: invalid recipient\");\n        \n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"WETH::convertFrom: convert amount exceeds allowance\");\n                allowance[from][msg.sender] = allowed - value;\n                emit Approval(from, msg.sender, allowed - value);\n            }\n        }\n        balanceOf[from] -= value;\n\n        emit Transfer(from, address(0), value);\n\n        weth9.deposit{value: value}();\n        require(weth9.transfer(to, value), \"WETH::convert: WETH transfer failed\");\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Approval} event.\n    function approve(address spender, uint256 value) external override returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token, given `owner` account's signed approval.\n    /// Emits {Approval} event.\n    /// Requirements:\n    ///   - `deadline` must be timestamp in future.\n    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\n    ///   - the signature must use `owner` account's current nonce (see {nonces}).\n    ///   - the signer cannot be zero address and must be `owner` account.\n    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\n    /// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(block.timestamp <= deadline, \"WETH::permit: Expired permit\");\n\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        bytes32 DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)));\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline));\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashStruct));\n\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0) && signer == owner, \"WETH::permit: invalid permit\");\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`).\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    function transfer(address to, uint256 value) external override returns (bool) {\n        require(balanceOf[msg.sender] >= value, \"WETH::transfer: transfer amount exceeds balance\");\n        require(to != address(this), \"WETH::transfer: invalid recipient\");\n\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n    /// Returns boolean value indicating whether operation succeeded.\n    ///\n    /// Emits {Transfer} and {Approval} events.\n    /// Requirements:\n    /// - owner account (`from`) must have at least `value` WETH10 token.\n    /// - caller account must have at least `value` allowance from account (`from`).\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n        require(balanceOf[from] >= value, \"WETH::transferFrom: transfer amount exceeds balance\");\n        require(to != address(this), \"WETH::transferFrom: invalid recipient\");\n\n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"WETH::transferFrom: transfer amount exceeds allowance\");\n                allowance[from][msg.sender] = allowed - value;\n                emit Approval(from, msg.sender, allowed - value);\n            }\n        }\n\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`), after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool success) {\n        require(balanceOf[msg.sender] >= value, \"WETH::transferAndCall: transfer amount exceeds balance\");\n        require(to != address(this), \"WETH::transferAndCall: invalid recipient\");\n\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n\n        ERC677Receiver(to).onTokenTransfer(msg.sender, value, data);\n        return true;\n    }\n}\n\n"
    },
    "contracts/IWETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2020\npragma solidity 0.7.0;\nimport \"./IERC2612.sol\";\nimport \"./IERC20.sol\";\n\n\n/// @dev WETH10 is an Ether ERC20 wrapper. You can `deposit` Ether and obtain Wrapped Ether which can then be operated as an ERC20 token. You can\n/// `withdraw` Ether from WETH10, which will burn Wrapped Ether in your wallet. The amount of Wrapped Ether in any wallet is always identical to the\n/// balance of Ether deposited minus the Ether withdrawn with that specific wallet.\ninterface IWETH10 is IERC20, IERC2612 {\n\n    /// @dev Returns current amount of flash minted WETH10 token.\n    function flashSupply() external view returns(uint256);\n\n    /// @dev `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    function deposit() external payable;\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to `to` account.\n    function depositTo(address to) external payable;\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance,\n    /// after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token and transfer to account (`to`) cannot cause overflow.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function depositToAndCall(address to, bytes calldata data) external payable returns (bool success);\n\n    /// @dev Flash mints WETH10 token and burns from caller account.\n    /// The flash minted WETH10 is not backed by real Ether, but can be withdrawn as such up to the Ether balance of this contract.\n    /// Arbitrary data can be passed as a bytes calldata parameter.\n    /// Emits two {Transfer} events for minting and burning of the flash minted amount.\n    function flashMint(uint256 value, bytes calldata data) external;\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to the same.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdraw(uint256 value) external;\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdrawTo(address to, uint256 value) external;\n\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ether to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function withdrawFrom(address from, address to, uint256 value) external;\n\n\n    /// @dev Exchange `value` WETH10 token from caller account for WETH9 token.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function convert(uint256 value) external;\n\n    /// @dev Exchange `value` WETH10 token from caller account for WETH9 token credited to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function convertTo(address to, uint256 value) external;\n\n    /// @dev Exchange `value` WETH10 token from account (`from`) for WETH9 token credited to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function convertFrom(address from, address to, uint256 value) external;\n\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`), after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function transferAndCall(address to, uint value, bytes calldata data) external returns (bool success);\n}\n\n"
    },
    "contracts/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/tests/TestERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub / adapted by [] 2020\npragma solidity 0.7.0;\n\n\ncontract TestERC677Receiver {\n    address public token;\n\n    event TransferReceived(address token, address sender, uint256 value, bytes data);\n\n    function onTokenTransfer(address sender, uint value, bytes calldata data) external {\n        emit TransferReceived(msg.sender, sender, value, data);\n    }\n}\n"
    },
    "contracts/tests/TestFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.0;\n\ninterface FlashMintableLike {\n    function flashMint(uint256, bytes calldata) external;\n    function balanceOf(address) external returns (uint256);\n    function deposit() external payable;\n    function withdraw(uint256) external;\n    function transfer(address, uint256) external;\n}\n\ncontract TestFlashMinter {\n    enum Action {NORMAL, STEAL, WITHDRAW, REENTER, OVERSPEND}\n\n    uint256 public flashBalance;\n    uint256 public flashValue;\n    address public flashUser;\n\n    receive() external payable {}\n\n    function executeOnFlashMint(bytes calldata data) external {\n        (Action action, address user, uint256 value) = abi.decode(data, (Action, address, uint256)); // Use this to unpack arbitrary data\n        flashUser = user;\n        flashValue = value;\n        if (action == Action.NORMAL) {\n            flashBalance = FlashMintableLike(msg.sender).balanceOf(address(this));\n        } else if (action == Action.WITHDRAW) {\n            FlashMintableLike(msg.sender).withdraw(value);\n            flashBalance = address(this).balance;\n            FlashMintableLike(msg.sender).deposit{ value: value }();\n        } else if (action == Action.STEAL) {\n            FlashMintableLike(msg.sender).transfer(address(1), value);\n        } else if (action == Action.REENTER) {\n            flashMint(msg.sender, value * 2);\n        } else if (action == Action.OVERSPEND) {\n            FlashMintableLike(msg.sender).transfer(address(0), 1);\n        }\n    }\n\n    function flashMint(address target, uint256 value) public {\n        // Use this to pack arbitrary data to `executeOnFlashMint`\n        bytes memory data = abi.encode(Action.NORMAL, msg.sender, value); // Here msg.sender is the user, and target is the weth contract\n        FlashMintableLike(target).flashMint(value, data);\n    }\n\n    function flashMintAndWithdraw(address target, uint256 value) public {\n        // Use this to pack arbitrary data to `executeOnFlashMint`\n        bytes memory data = abi.encode(Action.WITHDRAW, msg.sender, value); // Here msg.sender is the user, and target is the weth contract\n        FlashMintableLike(target).flashMint(value, data);\n    }\n\n    function flashMintAndSteal(address target, uint256 value) public {\n        // Use this to pack arbitrary data to `executeOnFlashMint`\n        bytes memory data = abi.encode(Action.STEAL, msg.sender, value); // Here msg.sender is the user, and target is the weth contract\n        FlashMintableLike(target).flashMint(value, data);\n    }\n\n    function flashMintAndReenter(address target, uint256 value) public {\n        // Use this to pack arbitrary data to `executeOnFlashMint`\n        bytes memory data = abi.encode(Action.REENTER, msg.sender, value); // Here msg.sender is the user, and target is the weth contract\n        FlashMintableLike(target).flashMint(value, data);\n    }\n\n    function flashMintAndOverspend(address target, uint256 value) public {\n        bytes memory data = abi.encode(Action.OVERSPEND, msg.sender, value); // Here msg.sender is the user, and target is the weth contract\n        FlashMintableLike(target).flashMint(value, data);\n    }\n}\n"
    },
    "contracts/tests/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.0;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}